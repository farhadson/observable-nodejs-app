Directory structure:
â””â”€â”€ observable-nodejs-app/
    â”œâ”€â”€ README.md
    â”œâ”€â”€ app.js
    â”œâ”€â”€ package.json
    â”œâ”€â”€ PREREQUISITES.md
    â”œâ”€â”€ README_REQ_FLOW.md
    â”œâ”€â”€ server.js
    â”œâ”€â”€ .env.example
    â”œâ”€â”€ config/
    â”‚   â”œâ”€â”€ database.js
    â”‚   â”œâ”€â”€ database.js[deprecate]
    â”‚   â”œâ”€â”€ logging.js
    â”‚   â”œâ”€â”€ metrics.js
    â”‚   â””â”€â”€ tracing.js
    â”œâ”€â”€ controllers/
    â”‚   â”œâ”€â”€ authController.js
    â”‚   â”œâ”€â”€ chaosController.js
    â”‚   â””â”€â”€ userController.js
    â”œâ”€â”€ middleware/
    â”‚   â”œâ”€â”€ errorHandler.js
    â”‚   â”œâ”€â”€ traceContext.js
    â”‚   â””â”€â”€ validation.js
    â”œâ”€â”€ models/
    â”‚   â””â”€â”€ userModel.js
    â”œâ”€â”€ prisma/
    â”‚   â”œâ”€â”€ schema.prisma
    â”‚   â””â”€â”€ seed.js
    â”œâ”€â”€ routes/
    â”‚   â”œâ”€â”€ authRoutes.js
    â”‚   â”œâ”€â”€ chaosRoutes.js
    â”‚   â””â”€â”€ userRoutes.js
    â”œâ”€â”€ services/
    â”‚   â”œâ”€â”€ authService.js
    â”‚   â”œâ”€â”€ chaosService.js
    â”‚   â”œâ”€â”€ databaseService.js[deprecate]
    â”‚   â””â”€â”€ userService.js
    â””â”€â”€ validators/
        â””â”€â”€ userValidator.js

================================================
FILE: README.md
================================================
# Tracing Application with OpenTelemetry & Tempo

A production-ready Node.js application with distributed tracing, metrics, and logging.

---

## Features

- âœ… **OpenTelemetry tracing** to Tempo with automatic instrumentation
- âœ… **Winston logging** with trace ID injection in every log
- âœ… **Prometheus metrics** with exemplars linking to traces
- âœ… **MVC architecture** with Express framework
- âœ… **PostgreSQL database** with Prisma ORM
- âœ… **JSON validation** using Joi library
- âœ… **Complete CRUD operations** ready to test
- âœ… **Chaos engineering** endpoints for testing
- âœ… **ES6+ features** annotated for learning

---

## Quick Setup

### 1. Install Dependencies

```
npm install
```

### 2. Configure Environment

```
cp .env.example .env 
# Edit .env with your configuration

or Create a `.env` file based on `.env.example`


Required variables:
DATABASE_URL="postgresql://user:password@localhost:5432/tracing_db"
JWT_SECRET="your-secret-key-here"
JWT_EXPIRES_IN="1h"
SERVICE_NAME="tracing-app"
SERVICE_VERSION="1.0.0"
OTLP_TRACE_DEST_URL="http://localhost:4318/v1/traces"
OTLP_TRACE_PROTOCOL="http"
LOG_LEVEL="info"
LOG_FILE_PATH="./logs/app.log"
PORT=3000
METRICS_PORT=9464
```

### 3. Setup Database

```
# Generate Prisma Client
npm run prisma:generate

# Run migrations
npm run prisma:migrate

# Optional: Seed database
npm run prisma:seed
```

### 4. Start Application

```
npm start
```

---

## CRUD Operations with curl

### Create User

```
curl -X POST http://localhost:3000/api/users \
  -H "Content-Type: application/json" \
  -d '{"email":"john@example.com","password":"password123","name":"John Doe"}'
```

### Login

```
curl -X POST http://localhost:3000/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{"email":"john@example.com","password":"password123"}'
```

### Get All Users

```
curl http://localhost:3000/api/users
```

### Get User by ID

```
curl http://localhost:3000/api/users/1
```

### Update User

```
curl -X PUT http://localhost:3000/api/users/1 \
  -H "Content-Type: application/json" \
  -d '{"name":"John Updated"}'
```

### Delete User

```
curl -X DELETE http://localhost:3000/api/users/1
```

### Health Check

```
curl http://localhost:3000/health
```

---

## Observability Endpoints

| Endpoint | Purpose | Exemplars | Port |
|----------|---------|-----------|------|
| `http://localhost:9464/metrics` | OpenTelemetry auto-instrumented metrics | âŒ No | 9464 |
| `http://localhost:3000/metrics-custom` | Custom metrics with trace exemplars | âœ… Yes | 3000 |
| `http://localhost:3000/health` | Health check endpoint | N/A | 3000 |

**Traces**: Automatically sent to Tempo at configured endpoint (see `.env`)

### Why Two Metrics Endpoints?

We maintain two metrics endpoints because:
1. **Port 9464** provides comprehensive auto-instrumented metrics from OpenTelemetry
2. **Port 3000** provides custom metrics with **exemplars** - allowing you to click from a metric spike in Grafana directly to the trace in Tempo

### Prometheus Configuration

Both should be scraped by Prometheus for complete observability.

## Exemplars

**What are exemplars?**
Exemplars link individual metric data points to their corresponding traces. When you see a latency spike in Grafana, you can click the exemplar to jump directly to the trace that caused it in Tempo.

### ðŸŽ¯ Key Takeaways on defining exemplars
1. Only Histograms and Counters support exemplars (not Gauges)
2. Strategic placement matters - add exemplars where you need debugging (HTTP, DB, errors)
3. prom-client only - OpenTelemetry metrics can't have exemplars in current version
4. We only had 2 because that's a minimal viable implementation
5. You should add more - especially error counter and HTTP request counter
6. Would you like me to provide the complete updated files with all exemplar-enabled metrics?

### ðŸ“Š Summary: Which Metrics Have Exemplars


The `/metrics-custom` endpoint provides these metrics with exemplar support (trace links):

- `http_request_duration_seconds_custom` - HTTP request latency histogram
- `http_requests_total_custom` - Total HTTP requests counter
- `database_query_duration_seconds_custom` - Database query latency histogram
- `application_errors_total` - Application errors counter

| Metric Name | Type | Exemplars | Use Case |
|-------------|------|-----------|----------|
| `http_request_duration_seconds_custom` | Histogram | âœ… | Link slow requests to traces |
| `http_requests_total_custom` | Counter | âœ… | Link request spikes to traces |
| `database_query_duration_seconds_custom` | Histogram | âœ… | Link slow queries to traces |
| `application_errors_total` | Counter | âœ… | Link errors to failing traces |
| `active_users_total` | UpDownCounter | âŒ | Current state, no trace link needed |
| `http_request_duration_seconds` (OTEL) | Histogram | âŒ | OpenTelemetry limitation |
| `http_requests_total` (OTEL) | Counter | âŒ | OpenTelemetry limitation |

## Architecture

The application follows **MVC architecture** with:

- **Controllers**: Handle HTTP requests/responses
- **Services**: Business logic layer
- **Models**: Data structures (Prisma ORM)
- **Middleware**: Request processing pipeline
- **Validators**: Input validation schemas (Joi)
- **Config**: Configuration modules for tracing, logging, metrics, and database

All operations are traced and linked to metrics via exemplars.

---

## Project Structure

```
tracing-app/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ config/           # Configuration (tracing, metrics, logging, db)
â”‚   â”œâ”€â”€ controllers/      # HTTP request handlers
â”‚   â”œâ”€â”€ middleware/       # Express middleware
â”‚   â”œâ”€â”€ models/           # Prisma ORM models
â”‚   â”œâ”€â”€ routes/           # API route definitions
â”‚   â”œâ”€â”€ services/         # Business logic
â”‚   â”œâ”€â”€ validators/       # Joi validation schemas
â”‚   â”œâ”€â”€ app.js            # Express app setup
â”‚   â””â”€â”€ server.js         # Server entry point
â”œâ”€â”€ prisma/
â”‚   â”œâ”€â”€ schema.prisma     # Database schema
â”‚   â””â”€â”€ seed.js           # Database seeding
â”œâ”€â”€ .env                  # Environment variables
â”œâ”€â”€ package.json          # Dependencies
â””â”€â”€ README.md             # This file
```

---

## Additional Documentation

- **[PREREQUISITES.md](./PREREQUISITES.md)** - Installation requirements and setup
- **[test-scenarios.md](./test-scenarios.md)** - Test scenarios for various use cases
- **[chaos-testing.md](./chaos-testing.md)** - Chaos engineering examples

---

## Tech Stack

- **Node.js** v18+
- **Express** v4.19+
- **PostgreSQL** v14+
- **Prisma ORM** v5.22+
- **OpenTelemetry** v0.54+
- **Winston** (logging)
- **Joi** (validation)
- **Prometheus** (metrics)
- **Tempo** (tracing backend)

---

## License

MIT


================================================
FILE: app.js
================================================
/**
 * @fileoverview Main Express application configuration.
 * Sets up middleware, routes, error handling, and observability endpoints.
 * @module app
 */

import express from 'express';
import authRoutes from './routes/authRoutes.js';
import userRoutes from './routes/userRoutes.js';
import chaosRoutes from './routes/chaosRoutes.js';
import traceContextMiddleware from './middleware/traceContext.js';
import errorHandler from './middleware/errorHandler.js';
// import logger from './config/logging.js';
import { recordHttpRequest, promRegister } from './config/metrics.js';

/**
 * Express application instance
 * @type {import('express').Application}
 */
const app = express();

// ============ MIDDLEWARE ============

/**
 * Parse JSON request bodies
 */
app.use(express.json());

/**
 * Parse URL-encoded request bodies
 */
app.use(express.urlencoded({ extended: true }));

/**
 * Inject OpenTelemetry trace context into requests
 */
app.use(traceContextMiddleware);

/**
 * Metrics middleware - records HTTP request metrics
 * @param {import('express').Request} req - Express request
 * @param {import('express').Response} res - Express response
 * @param {import('express').NextFunction} next - Next middleware
 */
/**
 * Metrics middleware - records HTTP request metrics
 * âœ… FIXED: Better route detection and timing
 */
app.use((req, res, next) => {
  const start = Date.now();
  
  // Capture metrics when response finishes
  const originalEnd = res.end;
  res.end = function(...args) {
    try {
      const duration = (Date.now() - start) / 1000;
      
      // Get route path (most reliable at response time)
      let route = 'unknown';
      if (req.route && req.route.path) {
        route = (req.baseUrl || '') + req.route.path;
      } else {
        route = req.path || req.url || 'unknown';
      }
      
      // Clean up route (remove query string)
      route = route.split('?')[0];
      
      // Record metrics
      if (typeof duration === 'number' && !isNaN(duration) && duration >= 0 &&
          typeof res.statusCode === 'number' && !isNaN(res.statusCode)) {
        recordHttpRequest(req.method, route, res.statusCode, duration);
      }
    } catch (error) {
      console.error('âŒ Metrics middleware error:', error.message);
    }
    
    // Call original end
    return originalEnd.apply(res, args);
  };
  
  next();
});

// ============ ROUTES ============

/**
 * Health check endpoint
 * @name GET /health
 * @function
 * @returns {Object} Health status and timestamp
 */
app.get('/health', (req, res) => {
  res.status(200).json({
    status: 'healthy',
    timestamp: new Date().toISOString()
  });
});

/**
 * Custom Prometheus metrics endpoint with exemplars
 * @name GET /metrics-custom
 * @function
 * @returns {string} Prometheus metrics in text format
 */
app.get('/metrics-custom', async (req, res) => {
  try {
    res.set('Content-Type', promRegister.contentType);
    const metrics = await promRegister.metrics();
    res.end(metrics);
  } catch (error) {
    res.status(500).end(error);
  }
});

/**
 * Mount API routes
 */
app.use('/api/auth', authRoutes);
app.use('/api/users', userRoutes);
app.use('/api/chaos', chaosRoutes);

/**
 * 404 handler for unmatched routes
 */
app.use((req, res) => {
  res.status(404).json({
    success: false,
    message: 'Route not found',
  });
});

/**
 * Global error handler middleware (must be last)
 */
app.use(errorHandler);

export default app;



================================================
FILE: package.json
================================================
{
  "name": "tracing-app",
  "version": "1.0.0",
  "type": "module",
  "description": "Node.js app with OpenTelemetry tracing to Tempo",
  "main": "src/server.js",
  "prisma": {
    "seed": "node prisma/seed.js"
  },
  "scripts": {
    "start": "node server.js",
    "dev": "node server.js",
    "prisma:generate": "prisma generate",
    "prisma:migrate": "prisma migrate dev",
    "prisma:studio": "prisma studio",
    "prisma:seed": "node prisma/seed.js"
  },
  "dependencies": {
    "@opentelemetry/api": "^1.9.0",
    "@opentelemetry/auto-instrumentations-node": "^0.50.0",
    "@opentelemetry/exporter-metrics-otlp-grpc": "^0.54.0",
    "@opentelemetry/exporter-metrics-otlp-http": "^0.54.0",
    "@opentelemetry/exporter-prometheus": "^0.54.0",
    "@opentelemetry/exporter-trace-otlp-grpc": "^0.54.0",
    "@opentelemetry/exporter-trace-otlp-http": "^0.54.0",
    "@opentelemetry/instrumentation": "^0.54.0",
    "@opentelemetry/instrumentation-express": "^0.43.0",
    "@opentelemetry/instrumentation-http": "^0.54.0",
    "@opentelemetry/resources": "^1.28.0",
    "@opentelemetry/sdk-metrics": "^1.28.0",
    "@opentelemetry/sdk-node": "^0.54.0",
    "@opentelemetry/sdk-trace-node": "^1.28.0",
    "@opentelemetry/semantic-conventions": "^1.28.0",
    "@prisma/client": "^5.22.0",
    "bcrypt": "^5.1.1",
    "dotenv": "^16.4.5",
    "express": "^4.19.2",
    "joi": "^17.13.3",
    "jsonwebtoken": "^9.0.2",
    "prom-client": "^15.1.3",
    "winston": "^3.14.2"
  },
  "devDependencies": {
    "prisma": "^5.22.0"
  }
}



================================================
FILE: PREREQUISITES.md
================================================
# Prerequisites and Installation Guide

## Required Software

### 1. Node.js (v18+ recommended)

**Check version:**
```
node --version  # Should be >= 18.0.0
npm --version   # Should be >= 9.0.0
```

**Install via nvm (recommended):**
```
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.0/install.sh | bash
nvm install 18
nvm use 18
```

### 2. PostgreSQL (v14+ recommended)

**Ubuntu/Debian:**
```
sudo apt update
sudo apt install postgresql postgresql-contrib postgresql-client
```

**macOS:**
```
brew install postgresql@14
brew services start postgresql@14
```

**Check version:**
```
psql --version  # Should be >= 14.0
```
### Connect to PostgreSQL as postgres user
`sudo -u postgres psql`

### Inside psql console, create the database:
`CREATE DATABASE tracing_db;`

### Verify it was created:
`\l`

### Exit psql:
`\q`


**Or use Docker:**
```
docker run --name postgres \
  -e POSTGRES_PASSWORD=postgres \
  -e POSTGRES_DB=tracing_db \
  -p 5432:5432 \
  -d postgres:14
```

### 3. Prisma CLI

Installed automatically via npm (in devDependencies).

**After npm install, verify:**
```
npx prisma --version
```

### 4. Tempo (for tracing backend)

**Create `docker-compose.yml`:**
```
version: '3'
services:
  tempo:
    image: grafana/tempo:latest
    ports:
      - "4317:4317"  # gRPC
      - "4318:4318"  # HTTP
    command: ["-config.file=/etc/tempo.yaml"]
    volumes:
      - ./tempo.yaml:/etc/tempo.yaml
```

**Create `tempo.yaml`:**
```
server:
  http_listen_port: 3200

distributor:
  receivers:
    otlp:
      protocols:
        grpc:
          endpoint: 0.0.0.0:4317
        http:
          endpoint: 0.0.0.0:4318

storage:
  trace:
    backend: local
    local:
      path: /tmp/tempo/traces

metrics_generator:
  storage:
    path: /tmp/tempo/generator
```

**Start Tempo:**
```
docker-compose up -d
```

### 5. Prometheus (for metrics)

**Create `prometheus.yml`:**
```
global:
  scrape_interval: 15s

scrape_configs:
  - job_name: 'node-app'
    static_configs:
      - targets: ['localhost:9464']
  
  - job_name: 'node-app-custom'
    static_configs:
      - targets: ['localhost:3000']
    metrics_path: '/metrics-custom'
```

**Run Prometheus:**
```
docker run -p 9090:9090 \
  -v $(pwd)/prometheus.yml:/etc/prometheus/prometheus.yml \
  prom/prometheus
```

---

## Installation Steps

### 1. Clone and Install Dependencies

```
npm install
```

### 2. Setup Database

```
# Create .env file
cp .env.example .env

# Edit DATABASE_URL in .env
# Format: postgresql://USER:PASSWORD@HOST:PORT/DATABASE

# Generate Prisma Client
npm run prisma:generate

# Run migrations (creates tables)
npm run prisma:migrate
npx prisma migrate dev --name init

# Seed database (optional)
npm run prisma:seed
```

### 3. Start Application

```
# Development
npm run dev

# Production
npm start
```

### 4. Verify Installation

```
# Check health
curl http://localhost:3000/health

# Check OpenTelemetry metrics
curl http://localhost:9464/metrics

# Check custom metrics with exemplars
curl http://localhost:3000/metrics-custom
```

---

## Package Versions Used

- **Node.js**: v18+ (LTS)
- **PostgreSQL**: v14+
- **Prisma**: v5.22.0
- **Express**: v4.19.2
- **OpenTelemetry SDK**: v0.54.0
- **Winston**: v3.14.2
- **Joi**: v17.13.3

---

## Optional Tools

- **Prisma Studio**: GUI for database
  ```
  npm run prisma:studio
  ```
- **k6**: Load testing
  ```
  brew install k6
  ```
- **curl**: API testing (pre-installed on most systems)
- **Docker**: For running Tempo/Prometheus
```




================================================
FILE: README_REQ_FLOW.md
================================================
[Binary file]


================================================
FILE: server.js
================================================
/**
 * @fileoverview Server entry point.
 * Starts the HTTP server and handles graceful shutdown.
 * @module server
 */

// âœ… Import tracing FIRST (before anything else)
import './config/tracing.js';

import app from './app.js';
import logger from './config/logging.js';
import dotenv from 'dotenv';

dotenv.config();

/**
 * Server port number
 * @type {number}
 */
const PORT = process.env.PORT || 3000;

/**
 * HTTP server instance
 * @type {import('http').Server}
 */
const server = app.listen(PORT, () => {
  logger.info(`Server started on port ${PORT}`);
  logger.info(`Health check: http://localhost:${PORT}/health`);
  logger.info(`Custom metrics: http://localhost:${PORT}/metrics-custom`);
  logger.info(`OpenTelemetry metrics: http://localhost:${process.env.METRICS_PORT || 9464}/metrics`);
});

/**
 * Graceful shutdown handler
 * Closes HTTP server and exits process
 */
process.on('SIGTERM', () => {
  logger.info('SIGTERM signal received: closing HTTP server');
  server.close(() => {
    logger.info('HTTP server closed');
  });
});



================================================
FILE: .env.example
================================================
# Server Configuration
PORT=3000
NODE_ENV=development

# Database Configuration (Prisma format)
### make sure database(tracing_db) exists and also does not have any passwords
### edit postgres sudo nano /etc/postgresql/14/main/pg_hba.conf
###host    all             all             127.0.0.1/32            trust
DATABASE_URL="postgresql://postgres@localhost:5432/tracing_db?schema=public"

# Tracing Configuration
# Use http:// for HTTP protocol, grpc:// for gRPC protocol
#OTLP_TRACE_DEST_URL=http://localhost:4318/v1/traces
#OTLP_TRACE_PROTOCOL=http
OTLP_TRACE_DEST_URL=localhost:4317
OTLP_TRACE_PROTOCOL=grpc

# Options: http or grpc
# http: Uses HTTP/1.1 (default, port 4318)
# grpc: Uses HTTP/2 over gRPC (port 4317)

# Service Information
SERVICE_NAME=tracing-app
SERVICE_VERSION=1.0.0

# Metrics Configuration (Prometheus pulls metrics, not pushed)
METRICS_PORT=9464

# Logging Configuration
LOG_LEVEL=info
LOG_FILE_PATH=./logs/app.log

# JWT Secret
### in prod use openssl to create a strong string: `openssl rand -hex 32`
### note: token gets expired provided secret never expires
JWT_SECRET=your-secret-key-change-in-production
JWT_EXPIRES_IN=1h


================================================
FILE: config/database.js
================================================
/**
 * @fileoverview Prisma Client singleton configuration.
 * Provides centralized database access for the application.
 * @module config/database
 */

import { PrismaClient } from '@prisma/client';
import logger from './logging.js';

/**
 * Prisma Client instance with query logging
 * @type {PrismaClient}
 * @constant
 */
const prisma = new PrismaClient({
  log: [
    { level: 'query', emit: 'event' },
    { level: 'error', emit: 'event' },
    { level: 'info', emit: 'event' },
    { level: 'warn', emit: 'event' },
  ],
});

/**
 * Log all queries with Winston
 */
prisma.$on('query', (e) => {
  logger.debug('Prisma Query', {
    query: e.query,
    params: e.params,
    duration: `${e.duration}ms`,
  });
});

/**
 * Log errors
 */
prisma.$on('error', (e) => {
  logger.error('Prisma Error', { error: e.message });
});

/**
 * Log connection events
 */
prisma.$on('info', (e) => {
  logger.info('Prisma Info', { message: e.message });
});

/**
 * Handle application shutdown
 */
process.on('beforeExit', async () => {
  await prisma.$disconnect();
  logger.info('Prisma Client disconnected');
});

export default prisma;



================================================
FILE: config/database.js[deprecate]
================================================
/**
 * @fileoverview PostgreSQL connection pool configuration using pg library.
 * Creates a singleton pool instance for database connections.
 * @module config/database
 */

import pg from 'pg';
import dotenv from 'dotenv';
import logger from './logging.js';

dotenv.config();

const { Pool } = pg;

/**
 * PostgreSQL connection pool instance
 * @type {pg.Pool}
 * @constant
 */
const pool = new Pool({
  host: process.env.DB_HOST || 'localhost',
  port: process.env.DB_PORT || 5432,
  database: process.env.DB_NAME || 'tracing_db',
  user: process.env.DB_USER || 'postgres',
  password: process.env.DB_PASSWORD || 'postgres',
  max: 20, // Maximum number of connections in pool
  idleTimeoutMillis: 30000, // Close idle connections after 30 seconds
  connectionTimeoutMillis: 2000, // Timeout for acquiring connection
});

/**
 * Event listener for successful database connections
 */
pool.on('connect', () => {
  logger.info('Database connection established');
});

/**
 * Event listener for database errors
 */
pool.on('error', (err) => {
  logger.error('Unexpected database error', { error: err.message });
});

export default pool;



================================================
FILE: config/logging.js
================================================
/**
 * @fileoverview Winston logger configuration with OpenTelemetry trace context injection.
 * Provides structured logging with trace ID and span ID in every log entry.
 * @module config/logging
 */

import winston from 'winston';
import dotenv from 'dotenv';
import { trace, context } from '@opentelemetry/api';

dotenv.config();

const { combine, timestamp, printf, colorize, errors } = winston.format;

/**
 * Custom log format with trace context
 * @type {winston.Logform.Format}
 */
const traceFormat = printf(({ level, message, timestamp, traceId, spanId, ...metadata }) => {
  const meta = Object.keys(metadata).length ? JSON.stringify(metadata) : '';
  return `${timestamp} [${level}] [TraceID: ${traceId || 'N/A'}] [SpanID: ${spanId || 'N/A'}]: ${message} ${meta}`;
});

/**
 * Winston format to add OpenTelemetry trace context to logs
 * @returns {winston.Logform.Format} Winston format instance
 */
const addTraceContext = winston.format((info) => {
  const span = trace.getSpan(context.active());
  if (span) {
    const spanContext = span.spanContext();
    info.traceId = spanContext.traceId;
    info.spanId = spanContext.spanId;
  }
  return info;
});

/**
 * Create a Winston logger instance with specified log level
 * @param {string} [logLevel='info'] - Minimum log level to output
 * @returns {winston.Logger} Configured Winston logger instance
 * 
 * @example
 * const logger = createLogger('debug');
 * logger.debug('Debug message');
 */
const createLogger = (logLevel = 'info') => {
  return winston.createLogger({
    level: logLevel,
    format: combine(
      errors({ stack: true }),
      timestamp({ format: 'YYYY-MM-DD HH:mm:ss' }),
      addTraceContext(),
      traceFormat
    ),
    transports: [
      new winston.transports.Console({
        format: combine(
          colorize(),
          traceFormat
        ),
      }),
      new winston.transports.File({
        filename: process.env.LOG_FILE_PATH || './logs/app.log',
        maxsize: 5242880, // 5MB
        maxFiles: 5,
      }),
    ],
  });
};

/**
 * Default logger instance
 * @type {winston.Logger}
 * @constant
 */
const logger = createLogger(process.env.LOG_LEVEL || 'info');

export default logger;



================================================
FILE: config/metrics.js
================================================
/**
 * @fileoverview OpenTelemetry metrics and Prometheus exporter configuration.
 * Provides metrics instrumentation with exemplar support linking metrics to traces.
 * Implements dual metrics strategy: OpenTelemetry auto-instrumentation (port 9464)
 * and custom prom-client metrics with exemplars (port 3000).
 * @module config/metrics
 */

import { metrics, trace, context } from '@opentelemetry/api';
import { PrometheusExporter } from '@opentelemetry/exporter-prometheus';
import { MeterProvider } from '@opentelemetry/sdk-metrics';
import { Resource } from '@opentelemetry/resources';
import { ATTR_SERVICE_NAME, ATTR_SERVICE_VERSION } from '@opentelemetry/semantic-conventions';
import client from 'prom-client';
import dotenv from 'dotenv';

dotenv.config();

// ============ OPENTELEMETRY METRICS (Port 9464) ============
// These are auto-exported but DON'T support exemplars

/**
 * OpenTelemetry Resource with service metadata
 * Provides service name and version for metric identification
 * @type {Resource}
 * @constant
 */
const resource = new Resource({
  [ATTR_SERVICE_NAME]: process.env.SERVICE_NAME || 'tracing-app',
  [ATTR_SERVICE_VERSION]: process.env.SERVICE_VERSION || '1.0.0',
});

/**
 * Prometheus Exporter for OpenTelemetry metrics
 * Exposes metrics at http://localhost:9464/metrics
 * These metrics do NOT support exemplars due to OpenTelemetry limitation
 * @type {PrometheusExporter}
 * @constant
 */
const prometheusExporter = new PrometheusExporter({
  port: parseInt(process.env.METRICS_PORT) || 9464,
}, () => {
  console.log(`Prometheus metrics available at http://localhost:${process.env.METRICS_PORT || 9464}/metrics`);
});

/**
 * OpenTelemetry MeterProvider
 * Manages metric instruments and exports to Prometheus
 * @type {MeterProvider}
 * @constant
 */
const meterProvider = new MeterProvider({
  resource,
  readers: [prometheusExporter],
});

// Set global meter provider for auto-instrumentation
metrics.setGlobalMeterProvider(meterProvider);

/**
 * Meter instance for creating metric instruments
 * @type {Meter}
 * @constant
 */
const meter = meterProvider.getMeter('app-metrics');

/**
 * HTTP request duration histogram (OpenTelemetry)
 * Tracks duration of HTTP requests in seconds
 * @type {Histogram}
 * @constant
 * @note Does NOT support exemplars - use httpDurationHistogram for exemplar support
 */
const httpRequestDuration_OTEL = meter.createHistogram('http_request_duration_seconds', {
  description: 'Duration of HTTP requests in seconds',
  unit: 'seconds',
});

/**
 * HTTP request counter (OpenTelemetry)
 * Tracks total number of HTTP requests
 * @type {Counter}
 * @constant
 * @note Does NOT support exemplars - use httpRequestCounterCustom for exemplar support
 */
const httpRequestCounter_OTEL = meter.createCounter('http_requests_total', {
  description: 'Total number of HTTP requests',
});

/**
 * Database query duration histogram (OpenTelemetry)
 * Tracks duration of database queries in seconds
 * @type {Histogram}
 * @constant
 * @note Does NOT support exemplars - use dbQueryHistogram for exemplar support
 */
const databaseQueryDuration_OTEL = meter.createHistogram('database_query_duration_seconds', {
  description: 'Duration of database queries in seconds',
  unit: 'seconds',
});

/**
 * Active users counter (OpenTelemetry)
 * Tracks current number of active users in the system
 * @type {UpDownCounter}
 * @constant
 * @note Gauges/UpDownCounters don't support exemplars by design (point-in-time values)
 */
const activeUsers = meter.createUpDownCounter('active_users_total', {
  description: 'Total number of active users',
});

// ============ CUSTOM PROM-CLIENT METRICS (Port 3000) ============
// These DO support exemplars (trace links)

/**
 * Custom Prometheus registry for prom-client metrics
 * Separate from OpenTelemetry registry to enable exemplar support
 * Exposed at http://localhost:3000/metrics-custom
 * @type {Registry}
 * @constant
 */
const promRegister = new client.Registry();
//Enable OpenMetrics support for exemplars
promRegister.setContentType(client.Registry.OPENMETRICS_CONTENT_TYPE);

/**
 * HTTP request duration histogram WITH EXEMPLARS
 * Tracks HTTP request latency and links data points to traces
 * Labels: method (GET/POST/etc), route (/api/users), status_code (200/404/etc)
 * @type {Histogram}
 * @constant
 * @example
 * // Recorded automatically by recordHttpRequest()
 * // Prometheus query: histogram_quantile(0.95, http_request_duration_seconds_custom)
 */
const httpDurationHistogram = new client.Histogram({
  name: 'http_request_duration_seconds_custom',
  help: 'Duration of HTTP requests in seconds with exemplars',
  labelNames: ['method', 'route', 'status_code'],
  buckets: [0.001, 0.01, 0.1, 0.5, 1, 2, 5],
  //// When OpenMetrics registry is enabled, The registry itslef will handle exemplars automatically.
  // enableExemplars: true, 
  registers: [promRegister],
});

/**
 * HTTP request counter WITH EXEMPLARS
 * Tracks total HTTP requests and links spikes to specific traces
 * Labels: method (GET/POST/etc), route (/api/users), status_code (200/404/etc)
 * @type {Counter}
 * @constant
 * @example
 * // Recorded automatically by recordHttpRequest()
 * // Prometheus query: rate(http_requests_total_custom[5m])
 */
const httpRequestCounterCustom = new client.Counter({
  name: 'http_requests_total_custom',
  help: 'Total number of HTTP requests with exemplars',
  labelNames: ['method', 'route', 'status_code'],
  // enableExemplars: true,
  registers: [promRegister],
});

/**
 * Database query duration histogram WITH EXEMPLARS
 * Tracks database query latency and links slow queries to traces
 * Labels: operation (CREATE/READ/UPDATE/DELETE), table (users/posts/etc)
 * @type {Histogram}
 * @constant
 * @example
 * // Recorded by recordDatabaseQuery()
 * // Prometheus query: histogram_quantile(0.99, database_query_duration_seconds_custom)
 */
const dbQueryHistogram = new client.Histogram({
  name: 'database_query_duration_seconds_custom',
  help: 'Duration of database queries with exemplars',
  labelNames: ['operation', 'table'],
  buckets: [0.001, 0.01, 0.05, 0.1, 0.5, 1],
  // enableExemplars: true,
  registers: [promRegister],
});

/**
 * Application error counter WITH EXEMPLARS
 * Tracks errors and links error spikes to failing traces
 * Labels: error_type (ValidationError/DatabaseError/etc), route (/api/users)
 * @type {Counter}
 * @constant
 * @example
 * // Recorded by recordError()
 * // Prometheus query: sum(rate(application_errors_total[5m])) by (error_type)
 */
const errorCounter = new client.Counter({
  name: 'application_errors_total',
  help: 'Total number of application errors with exemplars',
  labelNames: ['error_type', 'route'],
  // enableExemplars: true,
  registers: [promRegister],
});

// ============ RECORDING FUNCTIONS ============

/**
 * Record HTTP request metrics with trace exemplar
 * Records both OpenTelemetry metrics and custom prom-client metrics
 * Exemplars are automatically captured from OpenTelemetry context
 * @param {string} method - HTTP method
 * @param {string} route - Route path
 * @param {number} statusCode - HTTP status code
 * @param {number} duration - Request duration in seconds
 */
const recordHttpRequest = (method, route, statusCode, duration) => {
  // Validate inputs
  if (typeof duration !== 'number' || isNaN(duration) || duration < 0) {
    console.error('âŒ Invalid duration:', { method, route, statusCode, duration });
    return;
  }
  
  if (typeof statusCode !== 'number' || isNaN(statusCode)) {
    console.error('âŒ Invalid statusCode:', { method, route, statusCode, duration });
    return;
  }

  const routePath = String(route || 'unknown');
  const methodStr = String(method || 'UNKNOWN');
  
  // OpenTelemetry metrics
  try {
    httpRequestDuration_OTEL.record(duration, { 
      method: methodStr, 
      route: routePath, 
      status_code: statusCode 
    });
    httpRequestCounter_OTEL.add(1, { 
      method: methodStr, 
      route: routePath, 
      status_code: statusCode 
    });
  } catch (error) {
    console.error('âŒ OpenTelemetry metrics error:', error.message);
  }

  // prom-client metrics with automatic exemplar capture
  try {
    const labels = { 
      method: methodStr, 
      route: routePath, 
      status_code: statusCode 
    };
    
    // Exemplars are automatically captured from active OpenTelemetry span
    httpDurationHistogram.observe(labels, duration);
    httpRequestCounterCustom.inc(labels, 1);
    
  } catch (error) {
    console.error('âŒ prom-client metrics error:', {
      error: error.message,
      method: methodStr,
      route: routePath,
      statusCode,
      duration
    });
  }
};

/**
 * Record database query metrics with trace exemplar
 * Exemplars are automatically captured from OpenTelemetry context
 * @param {string} operation - Database operation type
 * @param {string} table - Database table name
 * @param {number} duration - Query duration in seconds
 */
const recordDatabaseQuery = (operation, table, duration) => {
  // OpenTelemetry metric
  try {
    databaseQueryDuration_OTEL.record(duration, { operation, table });
  } catch (error) {
    console.error('âŒ OpenTelemetry database metric error:', error.message);
  }

  // prom-client metric with automatic exemplar capture
  try {
    dbQueryHistogram.observe({ operation, table }, duration);
  } catch (error) {
    console.error('âŒ prom-client database metric error:', error.message);
  }
};

/**
 * Record application error with trace exemplar
 * Exemplars are automatically captured from OpenTelemetry context
 * @param {string} errorType - Error type/name
 * @param {string} route - Route where error occurred
 */
const recordError = (errorType, route) => {
  try {
    // Exemplar automatically captured from active span
    errorCounter.inc({ error_type: errorType, route }, 1);
  } catch (error) {
    console.error('âŒ Error recording error metric:', error.message);
  }
};

/**
 * @exports
 * @description Exports metrics and recording functions for application use
 * 
 * OpenTelemetry metrics (port 9464, no exemplars):
 * - httpRequestDuration: HTTP request duration histogram
 * - httpRequestCounter: HTTP request counter
 * - databaseQueryDuration: Database query duration histogram
 * - activeUsers: Active users gauge
 * 
 * Recording functions (auto-add exemplars):
 * - recordHttpRequest: Record HTTP request with trace link
 * - recordDatabaseQuery: Record database query with trace link
 * - recordError: Record error with trace link
 * 
 * Registry:
 * - promRegister: Custom registry for /metrics-custom endpoint
 * - meterProvider: OpenTelemetry meter provider
 */
export {
  // OpenTelemetry metrics (no exemplars)
  httpRequestDuration_OTEL as httpRequestDuration,
  httpRequestCounter_OTEL as httpRequestCounter,
  databaseQueryDuration_OTEL as databaseQueryDuration,
  activeUsers,
  
  // Recording functions (with exemplars)
  recordHttpRequest,
  recordDatabaseQuery,
  recordError,
  
  // Registries
  promRegister,
  meterProvider,
};



================================================
FILE: config/tracing.js
================================================
/**
 * @fileoverview OpenTelemetry tracing configuration and SDK initialization.
 * Configures trace export to Tempo via OTLP (HTTP or gRPC).
 * @module config/tracing
 */

import { NodeSDK } from '@opentelemetry/sdk-node';
import { OTLPTraceExporter as OTLPTraceExporterHTTP } from '@opentelemetry/exporter-trace-otlp-http';
import { OTLPTraceExporter as OTLPTraceExporterGRPC } from '@opentelemetry/exporter-trace-otlp-grpc';
import { Resource } from '@opentelemetry/resources';
import { ATTR_SERVICE_NAME, ATTR_SERVICE_VERSION } from '@opentelemetry/semantic-conventions';
import { getNodeAutoInstrumentations } from '@opentelemetry/auto-instrumentations-node';
import dotenv from 'dotenv';

dotenv.config();

/**
 * OTLP protocol type (http or grpc)
 * @type {string}
 * @constant
 */
const protocol = process.env.OTLP_TRACE_PROTOCOL || 'http';

/**
 * OTLP trace destination URL
 * @type {string}
 * @constant
 */
const url = process.env.OTLP_TRACE_DEST_URL || 'http://localhost:4318/v1/traces';

/**
 * Trace exporter instance (HTTP or gRPC)
 * @type {OTLPTraceExporterHTTP|OTLPTraceExporterGRPC}
 */
let traceExporter;

if (protocol === 'grpc') {
  console.log('Using gRPC exporter for traces (HTTP/2)');
  traceExporter = new OTLPTraceExporterGRPC({
    url: url.replace('http://', '').replace('https://', ''),
  });
} else {
  console.log('Using HTTP exporter for traces (HTTP/1.1)');
  traceExporter = new OTLPTraceExporterHTTP({ url });
}

/**
 * Service resource attributes
 * @type {Resource}
 * @constant
 */
const resource = new Resource({
  [ATTR_SERVICE_NAME]: process.env.SERVICE_NAME || 'tracing-app',
  [ATTR_SERVICE_VERSION]: process.env.SERVICE_VERSION || '1.0.0',
});

/**
 * OpenTelemetry Node SDK instance
 * @type {NodeSDK}
 * @constant
 */
const sdk = new NodeSDK({
  resource,
  traceExporter,
  instrumentations: [
    getNodeAutoInstrumentations({
      '@opentelemetry/instrumentation-fs': {
        enabled: false, // Disable fs instrumentation to reduce noise
      },
    }),
  ],
});

// Start SDK
sdk.start();

/**
 * Graceful shutdown handler for tracing
 */
process.on('SIGTERM', () => {
  sdk.shutdown()
    .then(() => console.log('Tracing terminated'))
    .catch((error) => console.log('Error terminating tracing', error))
    .finally(() => process.exit(0));
});

export { sdk };



================================================
FILE: controllers/authController.js
================================================
/**
 * @fileoverview Authentication controller handling login operations.
 * @module controllers/authController
 */

import userService from '../services/userService.js';
import logger from '../config/logging.js';

/**
 * Authentication controller class
 * @class
 */
class AuthController {
  /**
   * Handle user login
   * @async
   * @param {import('express').Request} req - Express request object
   * @param {import('express').Response} res - Express response object
   * @param {import('express').NextFunction} next - Express next middleware
   * @returns {Promise<void>}
   */
  async login(req, res, next) {
    try {
      const { email, password } = req.body;
      const result = await userService.authenticateUser(email, password);

      if (!result) {
        return res.status(401).json({
          success: false,
          message: 'Invalid credentials',
        });
      }

      logger.info('User logged in successfully', { userId: result.user.id });
      res.status(200).json({
        success: true,
        message: 'Login successful',
        data: result,
      });
    } catch (error) {
      next(error);
    }
  }
}

export default new AuthController();



================================================
FILE: controllers/chaosController.js
================================================
/**
 * @fileoverview Chaos engineering controller for testing system resilience.
 * @module controllers/chaosController
 */

import chaosService from '../services/chaosService.js';
import logger from '../config/logging.js';

/**
 * Chaos engineering controller class
 * @class
 */
class ChaosController {
  /**
   * Configure latency injection for a service
   * @async
   * @param {import('express').Request} req - Express request object
   * @param {import('express').Response} res - Express response object
   * @param {import('express').NextFunction} next - Express next middleware
   * @returns {Promise<void>}
   */
  async configureLatency(req, res, next) {
    try {
      const { service = 'database', duration = 1000, enabled = true } = req.body;
      chaosService.configureLatency(service, duration, enabled);
      
      res.status(200).json({
        success: true,
        message: `Latency configured for ${service}`,
        config: { service, duration, enabled },
      });
    } catch (error) {
      next(error);
    }
  }

  /**
   * Configure random failure injection for a service
   * @async
   * @param {import('express').Request} req - Express request object
   * @param {import('express').Response} res - Express response object
   * @param {import('express').NextFunction} next - Express next middleware
   * @returns {Promise<void>}
   */
  async configureRandomFailure(req, res, next) {
    try {
      const { service = 'database', probability = 0.5, enabled = true } = req.body;

      if (probability < 0 || probability > 1) {
        return res.status(400).json({
          success: false,
          message: 'Probability must be between 0 and 1',
        });
      }

      chaosService.configureFailureRate(service, probability, enabled);
      
      res.status(200).json({
        success: true,
        message: `Random failures configured for ${service}`,
        config: { service, probability, enabled },
      });
    } catch (error) {
      next(error);
    }
  }

  /**
   * Trigger memory leak simulation
   * @async
   * @param {import('express').Request} req - Express request object
   * @param {import('express').Response} res - Express response object
   * @param {import('express').NextFunction} next - Express next middleware
   * @returns {Promise<void>}
   */
  async triggerMemoryLeak(req, res, next) {
    try {
      const { duration = 30000 } = req.body;
      setImmediate(() => chaosService.simulateMemoryLeak(duration));
      
      res.status(200).json({
        success: true,
        message: 'Memory leak simulation started',
        duration,
      });
    } catch (error) {
      next(error);
    }
  }

  /**
   * Trigger CPU spike simulation
   * @async
   * @param {import('express').Request} req - Express request object
   * @param {import('express').Response} res - Express response object
   * @param {import('express').NextFunction} next - Express next middleware
   * @returns {Promise<void>}
   */
  async triggerCPUSpike(req, res, next) {
    try {
      const { duration = 5000 } = req.body;
      setImmediate(() => chaosService.simulateCPUSpike(duration));
      
      res.status(200).json({
        success: true,
        message: 'CPU spike simulation started',
        duration,
      });
    } catch (error) {
      next(error);
    }
  }

  /**
   * Trigger database error simulation
   * @async
   * @param {import('express').Request} req - Express request object
   * @param {import('express').Response} res - Express response object
   * @param {import('express').NextFunction} next - Express next middleware
   * @returns {Promise<void>}
   */
  async triggerDatabaseError(req, res, next) {
    try {
      const { errorType = 'CONNECTION_ERROR' } = req.body;
      await chaosService.simulateDatabaseError(errorType);
      res.status(200).json({ success: true });
    } catch (error) {
      next(error);
    }
  }

  /**
   * Disable all chaos engineering features
   * @async
   * @param {import('express').Request} req - Express request object
   * @param {import('express').Response} res - Express response object
   * @param {import('express').NextFunction} next - Express next middleware
   * @returns {Promise<void>}
   */
  async disableAll(req, res, next) {
    try {
      chaosService.disableAllChaos();
      res.status(200).json({
        success: true,
        message: 'All chaos features disabled',
      });
    } catch (error) {
      next(error);
    }
  }

  /**
   * Get current chaos configuration status
   * @async
   * @param {import('express').Request} req - Express request object
   * @param {import('express').Response} res - Express response object
   * @param {import('express').NextFunction} next - Express next middleware
   * @returns {Promise<void>}
   */
  async getStatus(req, res, next) {
    try {
      const status = chaosService.getStatus();
      res.status(200).json({
        success: true,
        data: status,
      });
    } catch (error) {
      next(error);
    }
  }

  /**
   * Test circuit breaker pattern with multiple failures
   * @async
   * @param {import('express').Request} req - Express request object
   * @param {import('express').Response} res - Express response object
   * @param {import('express').NextFunction} next - Express next middleware
   * @returns {Promise<void>}
   */
  async circuitBreakerTest(req, res, next) {
    try {
      const errors = [];

      for (let i = 0; i < 5; i++) {
        try {
          await chaosService.simulateDatabaseError('TIMEOUT');
        } catch (error) {
          errors.push({ attempt: i + 1, error: error.message });
        }
      }

      logger.warn('Circuit breaker test completed', { errorCount: errors.length });
      res.status(500).json({
        success: false,
        message: 'Circuit breaker test - multiple failures triggered',
        errors,
      });
    } catch (error) {
      next(error);
    }
  }
}

export default new ChaosController();



================================================
FILE: controllers/userController.js
================================================
/**
 * @fileoverview User controller handling CRUD operations for users.
 * @module controllers/userController
 */

import userService from '../services/userService.js';
// import logger from '../config/logging.js';

/**
 * User controller class
 * @class
 */
class UserController {
  /**
   * Create a new user
   * @async
   * @param {import('express').Request} req - Express request object
   * @param {import('express').Response} res - Express response object
   * @param {import('express').NextFunction} next - Express next middleware
   * @returns {Promise<void>}
   */
  async create(req, res, next) {
    try {
      const user = await userService.createUser(req.body);
      res.status(201).json({
        success: true,
        message: 'User created successfully',
        data: user,
      });
    } catch (error) {
      // if (error.code === '23505') {  // PostgreSQL error code
      if (error.code === 'P2002') {  // Prisma unique constraint error
        return res.status(409).json({
          success: false,
          message: 'Email already exists',
        });
      }
      next(error);
    }
  }

  /**
   * Get all users
   * @async
   * @param {import('express').Request} req - Express request object
   * @param {import('express').Response} res - Express response object
   * @param {import('express').NextFunction} next - Express next middleware
   * @returns {Promise<void>}
   */
  async getAll(req, res, next) {
    try {
      const users = await userService.getAllUsers();
      res.status(200).json({
        success: true,
        data: users,
      });
    } catch (error) {
      next(error);
    }
  }

  /**
   * Get user by ID
   * @async
   * @param {import('express').Request} req - Express request object
   * @param {import('express').Response} res - Express response object
   * @param {import('express').NextFunction} next - Express next middleware
   * @returns {Promise<void>}
   */
  async getById(req, res, next) {
    try {
      const userId = parseInt(req.params.id);
      const user = await userService.getUserById(userId);

      if (!user) {
        return res.status(404).json({
          success: false,
          message: 'User not found',
        });
      }

      res.status(200).json({
        success: true,
        data: user,
      });
    } catch (error) {
      next(error);
    }
  }

  /**
   * Update user by ID
   * @async
   * @param {import('express').Request} req - Express request object
   * @param {import('express').Response} res - Express response object
   * @param {import('express').NextFunction} next - Express next middleware
   * @returns {Promise<void>}
   */
  async update(req, res, next) {
    try {
      const userId = parseInt(req.params.id);
      const user = await userService.updateUser(userId, req.body);

      if (!user) {
        return res.status(404).json({
          success: false,
          message: 'User not found',
        });
      }

      res.status(200).json({
        success: true,
        message: 'User updated successfully',
        data: user,
      });
    } catch (error) {
      next(error);
    }
  }

  /**
   * Delete user by ID
   * @async
   * @param {import('express').Request} req - Express request object
   * @param {import('express').Response} res - Express response object
   * @param {import('express').NextFunction} next - Express next middleware
   * @returns {Promise<void>}
   */
  async delete(req, res, next) {
    try {
      const userId = parseInt(req.params.id);
      const deleted = await userService.deleteUser(userId);

      if (!deleted) {
        return res.status(404).json({
          success: false,
          message: 'User not found',
        });
      }

      res.status(200).json({
        success: true,
        message: 'User deleted successfully',
      });
    } catch (error) {
      next(error);
    }
  }
}

export default new UserController();



================================================
FILE: middleware/errorHandler.js
================================================
/**
 * @fileoverview Global error handling middleware for Express application.
 * Catches all errors thrown in the application and returns formatted responses.
 * Integrates with OpenTelemetry for error tracking and Winston for logging.
 * @module middleware/errorHandler
 */

import logger from '../config/logging.js';
import { trace, context } from '@opentelemetry/api';
import { recordError } from '../config/metrics.js';

/**
 * Global error handler middleware.
 * Catches all errors from routes and middleware, logs them, records in traces,
 * and sends appropriate HTTP responses to clients.
 * 
 * @param {Error} err - The error object thrown by the application
 * @param {import('express').Request} req - Express request object
 * @param {import('express').Response} res - Express response object
 * @param {import('express').NextFunction} next - Express next middleware function
 * @returns {void}
 * 
 * @example
 * // In app.js:
 * app.use(errorHandler);
 */
const errorHandler = (err, req, res, next) => {
  // next is not used but is required for express to identify error handling middleware
  // Get current span for error tracking
  const span = trace.getSpan(context.active());
  
  if (span) {
    span.recordException(err);
    span.setStatus({ code: 2, message: err.message }); // code 2 = ERROR
  }

  // Log error with trace context
  logger.error('Application error', {
    error: err.message,
    stack: err.stack,
    path: req.path,
    method: req.method,
    code: err.code,
  });

  // Determine status code
  const statusCode = err.statusCode || err.status || 500;

  recordError(err.name || 'UnknownError', req.path);

  // Prepare error response
  const errorResponse = {
    success: false,
    message: err.message || 'Internal Server Error',
    ...(process.env.NODE_ENV === 'development' && { stack: err.stack }),
  };

  // Add specific error details for known error types
  if (err.code) {
    errorResponse.code = err.code;
  }

  // Send error response
  res.status(statusCode).json(errorResponse);
};

export default errorHandler;


================================================
FILE: middleware/traceContext.js
================================================
/**
 * @fileoverview Middleware to inject OpenTelemetry trace context into Express requests.
 * Adds trace ID and span ID to request object and response headers.
 * @module middleware/traceContext
 */

import { trace, context } from '@opentelemetry/api';

/**
 * Trace context middleware
 * Extracts trace ID and span ID from active span and injects into request/response
 * 
 * @param {import('express').Request} req - Express request object
 * @param {import('express').Response} res - Express response object
 * @param {import('express').NextFunction} next - Express next middleware function
 * @returns {void}
 * 
 * @example
 * // In app.js:
 * app.use(traceContextMiddleware);
 * 
 * // In route handler:
 * console.log(req.traceId); // Access trace ID
 */
const traceContextMiddleware = (req, res, next) => {
  const span = trace.getSpan(context.active());
  
  if (span) {
    const spanContext = span.spanContext();
    req.traceId = spanContext.traceId;
    req.spanId = spanContext.spanId;
    
    // Add trace ID to response headers for client tracking
    res.setHeader('X-Trace-Id', spanContext.traceId);
  }
  
  next();
};

export default traceContextMiddleware;



================================================
FILE: middleware/validation.js
================================================
/**
 * @fileoverview Validation middleware using Joi schemas.
 * Validates request body, params, and query against provided Joi schema.
 * @module middleware/validation
 */

import logger from '../config/logging.js';

/**
 * Create validation middleware from Joi schema
 * @param {import('joi').Schema} schema - Joi validation schema
 * @returns {Function} Express middleware function
 * 
 * @example
 * import Joi from 'joi';
 * import validate from './middleware/validation.js';
 * 
 * const userSchema = Joi.object({
 *   email: Joi.string().email().required(),
 *   password: Joi.string().min(6).required()
 * });
 * 
 * router.post('/users', validate(userSchema), userController.create);
 */
const validate = (schema) => {
  /**
   * Validation middleware function
   * @param {import('express').Request} req - Express request object
   * @param {import('express').Response} res - Express response object
   * @param {import('express').NextFunction} next - Express next middleware function
   * @returns {void}
   */
  return (req, res, next) => {
    const dataToValidate = { ...req.body, ...req.params, ...req.query };

    const { error, value } = schema.validate(dataToValidate, {
      abortEarly: false,
      stripUnknown: true,
    });

    if (error) {
      const errors = error.details.map((detail) => ({
        message: detail.message,
        path: detail.path,
      }));

      logger.warn('Validation failed', { errors });
      
      return res.status(400).json({
        success: false,
        message: 'Validation failed',
        errors,
      });
    }

    // Replace req properties with validated values
    Object.assign(req.body, value);
    Object.assign(req.params, value);
    Object.assign(req.query, value);

    next();
  };
};

export default validate;



================================================
FILE: models/userModel.js
================================================
/**
 * @fileoverview User model using Prisma ORM for database operations.
 * @module models/userModel
 */

import prisma from '../config/database.js';
import logger from '../config/logging.js';

/**
 * User model class providing database operations
 * @class
 */
class UserModel {
  /**
   * Find user by ID
   * @async
   * @param {number} id - User ID
   * @returns {Promise<Object|null>} User object or null
   * 
   * @example
   * const user = await UserModel.findById(1);
   */
  async findById(id) {
    try {
      return await prisma.user.findUnique({
        where: { id },
        select: {
          id: true,
          email: true,
          name: true,
          createdAt: true,
          updatedAt: true,
        },
      });
    } catch (error) {
      logger.error('Error finding user by ID', { error: error.message, id });
      throw error;
    }
  }

  /**
   * Find user by email
   * @async
   * @param {string} email - User email
   * @returns {Promise<Object|null>} User object with password or null
   * 
   * @example
   * const user = await UserModel.findByEmail('john@example.com');
   */
  async findByEmail(email) {
    try {
      return await prisma.user.findUnique({
        where: { email },
      });
    } catch (error) {
      logger.error('Error finding user by email', { error: error.message, email });
      throw error;
    }
  }

  /**
   * Find all users
   * @async
   * @returns {Promise<Array<Object>>} Array of user objects
   * 
   * @example
   * const users = await UserModel.findAll();
   */
  async findAll() {
    try {
      return await prisma.user.findMany({
        select: {
          id: true,
          email: true,
          name: true,
          createdAt: true,
          updatedAt: true,
        },
      });
    } catch (error) {
      logger.error('Error finding all users', { error: error.message });
      throw error;
    }
  }

  /**
   * Create new user
   * @async
   * @param {Object} userData - User data
   * @param {string} userData.email - User email
   * @param {string} userData.password - Hashed password
   * @param {string} userData.name - User name
   * @returns {Promise<Object>} Created user object without password
   * 
   * @example
   * const user = await UserModel.create({
   *   email: 'john@example.com',
   *   password: 'hashedPassword',
   *   name: 'John Doe'
   * });
   */
  async create(userData) {
    try {
      const user = await prisma.user.create({
        data: userData,
        select: {
          id: true,
          email: true,
          name: true,
          createdAt: true,
          updatedAt: true,
        },
      });
      return user;
    } catch (error) {
      logger.error('Error creating user', { error: error.message });
      throw error;
    }
  }

  /**
   * Update user by ID
   * @async
   * @param {number} id - User ID
   * @param {Object} updates - Fields to update
   * @returns {Promise<Object>} Updated user object
   * 
   * @example
   * const user = await UserModel.update(1, { name: 'Jane Doe' });
   */
  async update(id, updates) {
    try {
      return await prisma.user.update({
        where: { id },
        data: updates,
        select: {
          id: true,
          email: true,
          name: true,
          createdAt: true,
          updatedAt: true,
        },
      });
    } catch (error) {
      logger.error('Error updating user', { error: error.message, id });
      throw error;
    }
  }

  /**
   * Delete user by ID
   * @async
   * @param {number} id - User ID
   * @returns {Promise<Object>} Deleted user object
   * 
   * @example
   * await UserModel.delete(1);
   */
  async delete(id) {
    try {
      return await prisma.user.delete({
        where: { id },
      });
    } catch (error) {
      logger.error('Error deleting user', { error: error.message, id });
      throw error;
    }
  }
}

export default new UserModel();



================================================
FILE: prisma/schema.prisma
================================================
// Prisma ORM schema definition
generator client {
  provider = "prisma-client-js"
  // ES6+ Feature: This generates TypeScript types for database models
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        Int      @id @default(autoincrement())
  email     String   @unique
  password  String
  name      String
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@map("users")
  @@index([email])
}

// Add more models as needed
model Post {
  id        Int      @id @default(autoincrement())
  title     String
  content   String?
  published Boolean  @default(false)
  authorId  Int      @map("author_id")
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@map("posts")
  @@index([authorId])
}



================================================
FILE: prisma/seed.js
================================================
/**
 * @fileoverview Database seeding script for initial data population.
 * @module prisma/seed
 */

import { PrismaClient } from '@prisma/client';
import bcrypt from 'bcrypt';

const prisma = new PrismaClient();

/**
 * Main seed function
 * @async
 * @returns {Promise<void>}
 */
async function main() {
  console.log('ðŸŒ± Starting database seed...');

  /**
   * Hashed password for demo users
   * @type {string}
   */
  const hashedPassword = await bcrypt.hash('password123', 10);

  /**
   * Create demo users
   */
  const user1 = await prisma.user.upsert({
    where: { email: 'john@example.com' },
    update: {},
    create: {
      email: 'john@example.com',
      name: 'John Doe',
      password: hashedPassword,
    },
  });

  const user2 = await prisma.user.upsert({
    where: { email: 'jane@example.com' },
    update: {},
    create: {
      email: 'jane@example.com',
      name: 'Jane Smith',
      password: hashedPassword,
    },
  });

  console.log('âœ… Created users:', { user1, user2 });
  console.log('ðŸŒ± Database seeding completed!');
}

/**
 * Execute main function and handle errors
 */
main()
  .catch((e) => {
    console.error('âŒ Error during seeding:', e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });



================================================
FILE: routes/authRoutes.js
================================================
/**
 * @fileoverview Authentication routes for login and registration.
 * @module routes/authRoutes
 */

import express from 'express';
import authController from '../controllers/authController.js';
import validate from '../middleware/validation.js';
import { loginSchema } from '../validators/userValidator.js';

/**
 * Express router for authentication endpoints
 * @type {express.Router}
 * @constant
 */
const router = express.Router();

/**
 * User login route
 * @name POST /api/auth/login
 * @function
 * @memberof module:routes/authRoutes
 * @param {Object} req.body - Request body
 * @param {string} req.body.email - User email
 * @param {string} req.body.password - User password
 * @returns {Object} 200 - Login successful with JWT token
 * @returns {Object} 401 - Invalid credentials
 */
router.post('/login', validate(loginSchema), authController.login);

export default router;



================================================
FILE: routes/chaosRoutes.js
================================================
/**
 * @fileoverview Chaos engineering routes for testing system resilience.
 * @module routes/chaosRoute
 */

import express from 'express';
import chaosController from '../controllers/chaosController.js';

/**
 * Express router for chaos engineering endpoints
 * @type {express.Router}
 * @constant
 */
const router = express.Router();

/**
 * Configure latency injection
 * @name POST /api/chaos/latency
 * @function
 * @memberof module:routes/chaosRoute
 */
router.post('/latency', chaosController.configureLatency);

/**
 * Configure random failure injection
 * @name POST /api/chaos/random-failure
 * @function
 * @memberof module:routes/chaosRoute
 */
router.post('/random-failure', chaosController.configureRandomFailure);

/**
 * Trigger memory leak simulation
 * @name POST /api/chaos/memory-leak
 * @function
 * @memberof module:routes/chaosRoute
 */
router.post('/memory-leak', chaosController.triggerMemoryLeak);

/**
 * Trigger CPU spike simulation
 * @name POST /api/chaos/cpu-spike
 * @function
 * @memberof module:routes/chaosRoute
 */
router.post('/cpu-spike', chaosController.triggerCPUSpike);

/**
 * Trigger database error
 * @name POST /api/chaos/database-error
 * @function
 * @memberof module:routes/chaosRoute
 */
router.post('/database-error', chaosController.triggerDatabaseError);

/**
 * Disable all chaos features
 * @name POST /api/chaos/disable-all
 * @function
 * @memberof module:routes/chaosRoute
 */
router.post('/disable-all', chaosController.disableAll);

/**
 * Get chaos status
 * @name GET /api/chaos/status
 * @function
 * @memberof module:routes/chaosRoute
 */
router.get('/status', chaosController.getStatus);

/**
 * Circuit breaker test
 * @name POST /api/chaos/circuit-breaker-test
 * @function
 * @memberof module:routes/chaosRoute
 */
router.post('/circuit-breaker-test', chaosController.circuitBreakerTest);

export default router;



================================================
FILE: routes/userRoutes.js
================================================
/**
 * @fileoverview User CRUD routes.
 * @module routes/userRoutes
 */

import express from 'express';
import userController from '../controllers/userController.js';
import validate from '../middleware/validation.js';
import { createUserSchema, updateUserSchema } from '../validators/userValidator.js';

/**
 * Express router for user endpoints
 * @type {express.Router}
 * @constant
 */
const router = express.Router();

/**
 * Get all users
 * @name GET /api/users
 * @function
 * @memberof module:routes/userRoutes
 * @returns {Object} 200 - Array of users
 */
router.get('/', userController.getAll);

/**
 * Get user by ID
 * @name GET /api/users/:id
 * @function
 * @memberof module:routes/userRoutes
 * @param {string} req.params.id - User ID
 * @returns {Object} 200 - User object
 * @returns {Object} 404 - User not found
 */
router.get('/:id', userController.getById);

/**
 * Create new user
 * @name POST /api/users
 * @function
 * @memberof module:routes/userRoutes
 * @param {Object} req.body - User data
 * @returns {Object} 201 - Created user
 * @returns {Object} 409 - Email already exists
 */
router.post('/', validate(createUserSchema), userController.create);

/**
 * Update user by ID
 * @name PUT /api/users/:id
 * @function
 * @memberof module:routes/userRoutes
 * @param {string} req.params.id - User ID
 * @param {Object} req.body - Updated user data
 * @returns {Object} 200 - Updated user
 * @returns {Object} 404 - User not found
 */
router.put('/:id', validate(updateUserSchema), userController.update);

/**
 * Delete user by ID
 * @name DELETE /api/users/:id
 * @function
 * @memberof module:routes/userRoutes
 * @param {string} req.params.id - User ID
 * @returns {Object} 200 - Deletion successful
 * @returns {Object} 404 - User not found
 */
router.delete('/:id', userController.delete);

export default router;



================================================
FILE: services/authService.js
================================================
/**
 * @fileoverview Authentication service for password hashing and JWT operations.
 * Handles user authentication, password encryption, and token generation/verification.
 * @module services/authService
 */

import bcrypt from 'bcrypt';
import jwt from 'jsonwebtoken';
import dotenv from 'dotenv';
import logger from '../config/logging.js';
import { trace } from '@opentelemetry/api';

dotenv.config();

/**
 * Authentication service class
 * @class
 */
class AuthService {
  /**
   * Hash a plain text password using bcrypt
   * @async
   * @param {string} password - Plain text password to hash
   * @returns {Promise<string>} Hashed password
   * @throws {Error} If hashing fails
   * 
   * @example
   * const hashedPassword = await authService.hashPassword('myPassword123');
   */
  async hashPassword(password) {
    const tracer = trace.getTracer('auth-service');
    return tracer.startActiveSpan('auth.hashPassword', async (span) => {
      try {
        const saltRounds = 10;
        const hashed = await bcrypt.hash(password, saltRounds);
        logger.info('Password hashed successfully');
        return hashed;
      } catch (error) {
        span.recordException(error);
        logger.error('Password hashing failed', { error: error.message });
        throw error;
      } finally {
        span.end();
      }
    });
  }

  /**
   * Compare a plain text password with a hashed password
   * @async
   * @param {string} password - Plain text password
   * @param {string} hashedPassword - Hashed password to compare against
   * @returns {Promise<boolean>} True if passwords match, false otherwise
   * @throws {Error} If comparison fails
   * 
   * @example
   * const isValid = await authService.comparePassword('myPassword123', hashedPassword);
   */
  async comparePassword(password, hashedPassword) {
    const tracer = trace.getTracer('auth-service');
    return tracer.startActiveSpan('auth.comparePassword', async (span) => {
      try {
        const isMatch = await bcrypt.compare(password, hashedPassword);
        logger.info('Password comparison completed', { matched: isMatch });
        return isMatch;
      } catch (error) {
        span.recordException(error);
        logger.error('Password comparison failed', { error: error.message });
        throw error;
      } finally {
        span.end();
      }
    });
  }

  /**
   * Generate a JWT token for authenticated user
   * @param {Object} payload - Token payload
   * @param {number} payload.userId - User ID
   * @param {string} payload.email - User email
   * @returns {string} Signed JWT token
   * @throws {Error} If token generation fails
   * 
   * @example
   * const token = authService.generateToken({ userId: 1, email: 'user@example.com' });
   */
  generateToken({ userId, email }) {
    const tracer = trace.getTracer('auth-service');
    const span = tracer.startSpan('auth.generateToken');
    try {
      const token = jwt.sign(
        { userId, email },
        process.env.JWT_SECRET || 'default-secret',
        { expiresIn: process.env.JWT_EXPIRES_IN || '1h' }
      );
      logger.info('JWT token generated', { userId });
      return token;
    } catch (error) {
      span.recordException(error);
      logger.error('Token generation failed', { error: error.message });
      throw error;
    } finally {
      span.end();
    }
  }

  /**
   * Verify and decode a JWT token
   * @param {string} token - JWT token to verify
   * @returns {Object} Decoded token payload
   * @returns {number} returns.userId - User ID from token
   * @returns {string} returns.email - User email from token
   * @throws {Error} If token verification fails
   * 
   * @example
   * const decoded = authService.verifyToken(token);
   * console.log(decoded.userId, decoded.email);
   */
  verifyToken(token) {
    const tracer = trace.getTracer('auth-service');
    const span = tracer.startSpan('auth.verifyToken');
    try {
      const decoded = jwt.verify(token, process.env.JWT_SECRET || 'default-secret');
      logger.info('Token verified successfully');
      return decoded;
    } catch (error) {
      span.recordException(error);
      logger.error('Token verification failed', { error: error.message });
      throw error;
    } finally {
      span.end();
    }
  }
}

export default new AuthService();



================================================
FILE: services/chaosService.js
================================================
/**
 * @fileoverview Chaos engineering service for testing system resilience.
 * Provides methods to inject latency, trigger failures, and simulate various error conditions.
 * @module services/chaosService
 */

import logger from '../config/logging.js';
import { trace } from '@opentelemetry/api';

/**
 * Chaos engineering service class
 * @class
 */
class ChaosService {
  /**
   * Initialize chaos service with configuration map
   * @constructor
   */
  constructor() {
    this.config = new Map();
    this.config.set('database', { latency: 0, failureRate: 0, enabled: false });
    this.config.set('api', { latency: 0, failureRate: 0, enabled: false });
    this.memoryLeakInterval = null;
  }

  /**
   * Inject latency delay into a service
   * @async
   * @param {string} service - Service name ('database' or 'api')
   * @param {number} [duration] - Duration in milliseconds (uses config if not provided)
   * @returns {Promise<void>}
   * 
   * @example
   * await chaosService.injectLatency('database', 2000);
   */
  async injectLatency(service, duration) {
    const config = this.config.get(service);
    if (!config || !config.enabled || config.latency === 0) {
      return;
    }

    const tracer = trace.getTracer('chaos-service');
    const span = tracer.startSpan('chaos.latency');
    try {
      span.setAttribute('chaos.service', service);
      span.setAttribute('chaos.latency_ms', duration || config.latency);
      logger.warn(`Chaos: Injecting ${duration || config.latency}ms latency into ${service}`);
      await new Promise(resolve => setTimeout(resolve, duration || config.latency));
    } finally {
      span.end();
    }
  }

  /**
   * Randomly trigger failure based on configured probability
   * @async
   * @param {string} service - Service name
   * @returns {Promise<boolean>} True if failure was triggered, false otherwise
   * 
   * @example
   * const failed = await chaosService.injectRandomFailure('database');
   */
  async injectRandomFailure(service) {
    const config = this.config.get(service);
    if (!config || !config.enabled || config.failureRate === 0) {
      return false;
    }

    const tracer = trace.getTracer('chaos-service');
    const span = tracer.startSpan('chaos.random_failure');
    try {
      const shouldFail = Math.random() < config.failureRate;
      span.setAttribute('chaos.service', service);
      span.setAttribute('chaos.failure_rate', config.failureRate);
      span.setAttribute('chaos.failed', shouldFail);

      if (shouldFail) {
        logger.warn(`Chaos: Triggering random failure in ${service}`);
        const error = new Error(`Chaos-induced failure in ${service}`);
        span.recordException(error);
        return true;
      }

      return false;
    } finally {
      span.end();
    }
  }

  /**
   * Configure latency injection for a service
   * @param {string} service - Service name
   * @param {number} duration - Latency duration in milliseconds
   * @param {boolean} [enabled=true] - Enable or disable latency injection
   * @returns {void}
   * 
   * @example
   * chaosService.configureLatency('database', 1000, true);
   */
  configureLatency(service, duration, enabled = true) {
    const config = this.config.get(service) || {};
    config.latency = duration;
    config.enabled = enabled;
    this.config.set(service, config);
    logger.info(`Chaos: Configured latency for ${service}`, { duration, enabled });
  }

  /**
   * Configure random failure rate for a service
   * @param {string} service - Service name
   * @param {number} rate - Failure probability (0.0 to 1.0)
   * @param {boolean} [enabled=true] - Enable or disable failure injection
   * @returns {void}
   * 
   * @example
   * chaosService.configureFailureRate('database', 0.3, true);
   */
  configureFailureRate(service, rate, enabled = true) {
    const config = this.config.get(service) || {};
    config.failureRate = rate;
    config.enabled = enabled;
    this.config.set(service, config);
    logger.info(`Chaos: Configured failure rate for ${service}`, { rate, enabled });
  }

  /**
   * Simulate memory leak by continuously allocating memory
   * @param {number} [durationMs=30000] - Duration of memory leak in milliseconds
   * @returns {void}
   * 
   * @example
   * chaosService.simulateMemoryLeak(60000); // 60 seconds
   */
  simulateMemoryLeak(durationMs = 30000) {
    logger.warn('Chaos: Starting memory leak simulation', { duration: durationMs });
    const memoryLeakArray = [];
    let iterations = 0;

    this.memoryLeakInterval = setInterval(() => {
      // Allocate ~10MB per iteration
      memoryLeakArray.push(new Array(1000000).fill('*'.repeat(10)));
      iterations++;
      logger.warn('Chaos: Memory leak iteration', {
        iteration: iterations,
        arraySize: memoryLeakArray.length
      });
    }, 1000);

    setTimeout(() => {
      clearInterval(this.memoryLeakInterval);
      logger.info('Chaos: Memory leak simulation ended');
    }, durationMs);
  }

  /**
   * Simulate CPU spike by running intensive calculations
   * @param {number} [durationMs=5000] - Duration of CPU spike in milliseconds
   * @returns {void}
   * 
   * @example
   * chaosService.simulateCPUSpike(10000); // 10 seconds
   */
  simulateCPUSpike(durationMs = 5000) {
    logger.warn('Chaos: Starting CPU spike simulation', { duration: durationMs });
    const tracer = trace.getTracer('chaos-service');
    const span = tracer.startSpan('chaos.cpu_spike');
    try {
      span.setAttribute('chaos.duration_ms', durationMs);
      const start = Date.now();
      
      while (Date.now() - start < durationMs) {
        // Busy wait to consume CPU
        Math.sqrt(Math.random() * 1000000);
      }

      logger.info('Chaos: CPU spike simulation completed');
    } finally {
      span.end();
    }
  }

  /**
   * Simulate database error with specific error type
   * @async
   * @param {string} [errorType='CONNECTION_ERROR'] - Type of database error
   * @throws {Error} Database error based on error type
   * 
   * @example
   * try {
   *   await chaosService.simulateDatabaseError('TIMEOUT');
   * } catch (error) {
   *   console.error('Database error:', error.message);
   * }
   */
  async simulateDatabaseError(errorType = 'CONNECTION_ERROR') {
    const tracer = trace.getTracer('chaos-service');
    const span = tracer.startSpan('chaos.database_error');
    try {
      span.setAttribute('chaos.error_type', errorType);
      logger.error('Chaos: Simulating database error', { errorType });

      const errors = {
        CONNECTION_ERROR: new Error('ECONNREFUSED: Connection refused'),
        TIMEOUT: new Error('ETIMEDOUT: Query timeout'),
        DEADLOCK: new Error('Deadlock detected'),
        CONSTRAINT_VIOLATION: new Error('Unique constraint violation'),
      };

      const error = errors[errorType] || new Error('Unknown database error');
      span.recordException(error);
      throw error;
    } finally {
      span.end();
    }
  }

  /**
   * Disable all chaos engineering features
   * @returns {void}
   * 
   * @example
   * chaosService.disableAllChaos();
   */
  disableAllChaos() {
    for (const [service, config] of this.config.entries()) {
      config.enabled = false;
      config.latency = 0;
      config.failureRate = 0;
    }

    if (this.memoryLeakInterval) {
      clearInterval(this.memoryLeakInterval);
    }

    logger.info('Chaos: All chaos engineering features disabled');
  }

  /**
   * Get current chaos configuration status
   * @returns {Object} Current configuration for all services
   * 
   * @example
   * const status = chaosService.getStatus();
   * console.log(status);
   */
  getStatus() {
    return Object.fromEntries(this.config);
  }
}

export default new ChaosService();



================================================
FILE: services/databaseService.js[deprecate]
================================================
/**
 * @fileoverview Legacy database service wrapper for raw SQL queries.
 * Provides backward compatibility for raw SQL with chaos engineering support.
 * Uses Prisma Client for query execution.
 * @module services/databaseService
 * @deprecated Prefer using Prisma models directly for type safety
 */

import prisma from '../config/database.js';
import logger from '../config/logging.js';
import { recordDatabaseQuery } from '../config/metrics.js';  // â­ ADD THIS
import { trace } from '@opentelemetry/api';
import chaosService from './chaosService.js';

/**
 * Database service class for raw SQL queries with chaos engineering
 * @class
 * @deprecated Use Prisma models directly instead of raw queries
 */
class DatabaseService {
  /**
   * Execute a raw SQL query with chaos engineering and observability
   * @async
   * @param {string} query - Raw SQL query string
   * @param {Array} [params=[]] - Query parameters (for parameterized queries)
   * @returns {Promise<Object>} Query result with rows and rowCount
   * @returns {Array} returns.rows - Result rows
   * @returns {number} returns.rowCount - Number of rows returned
   * @throws {Error} If query execution fails or chaos is triggered
   * 
   * @example
   * const result = await databaseService.query(
   *   'SELECT * FROM users WHERE id = $1',
   *   [userId]
   * );
   * console.log(result.rows);
   */
  async query(query, params = []) {
    const tracer = trace.getTracer('database-service');
    return tracer.startActiveSpan('db.query', async (span) => {
      const start = Date.now();
      
      try {
        span.setAttribute('db.system', 'postgresql');
        span.setAttribute('db.statement', query);

        // Inject chaos latency
        await chaosService.injectLatency('database');
        
        // Check for chaos-induced failures
        const shouldFail = await chaosService.injectRandomFailure('database');
        if (shouldFail) {
          throw new Error('Chaos-induced database failure');
        }

        // Execute raw SQL query using Prisma
        const result = await prisma.$queryRawUnsafe(query, ...params);
        
        const duration = (Date.now() - start) / 1000;

        // â­ Record database metrics with exemplars
        recordDatabaseQuery('RAW_SQL', 'multiple', duration);

        logger.info('Database query executed', {
          duration: `${duration}s`,
          rowCount: result.length
        });

        return { rows: result, rowCount: result.length };
      } catch (error) {
        span.recordException(error);
        
        const duration = (Date.now() - start) / 1000;
        
        // â­ Record failed query metrics
        recordDatabaseQuery('RAW_SQL', 'multiple', duration);
        
        logger.error('Database query failed', {
          error: error.message,
          query: query.substring(0, 100)
        });
        
        throw error;
      } finally {
        span.end();
      }
    });
  }

  /**
   * Get a Prisma client transaction
   * @async
   * @returns {Promise<PrismaClient>} Prisma client instance
   * @deprecated Use Prisma transactions directly via prisma.$transaction()
   * 
   * @example
   * const client = await databaseService.getClient();
   * await client.user.create({...});
   */
  async getClient() {
    return prisma;
  }
}

export default new DatabaseService();



================================================
FILE: services/userService.js
================================================
/**
 * @fileoverview User service handling business logic for user operations.
 * Manages user CRUD operations, authentication, and integrates with Prisma ORM.
 * @module services/userService
 */

import UserModel from '../models/userModel.js';
import authService from './authService.js';
import logger from '../config/logging.js';
import { trace } from '@opentelemetry/api';

/**
 * User service class
 * @class
 */
class UserService {
  /**
   * Create a new user with hashed password
   * @async
   * @param {Object} userData - User data object
   * @param {string} userData.email - User email address
   * @param {string} userData.password - Plain text password
   * @param {string} userData.name - User full name
   * @returns {Promise<Object>} Created user object (without password)
   * @throws {Error} If user creation fails
   * 
   * @example
   * const user = await userService.createUser({
   *   email: 'john@example.com',
   *   password: 'password123',
   *   name: 'John Doe'
   * });
   */
  async createUser(userData) {
    const tracer = trace.getTracer('user-service');
    return tracer.startActiveSpan('user.create', async (span) => {
      try {
        const { email, password, name } = userData;
        span.setAttribute('user.email', email);

        const hashedPassword = await authService.hashPassword(password);
        const user = await UserModel.create({
          email,
          password: hashedPassword,
          name,
        });

        logger.info('User created successfully', { userId: user.id });
        return user;
      } catch (error) {
        span.recordException(error);
        logger.error('User creation failed', { error: error.message });
        throw error;
      } finally {
        span.end();
      }
    });
  }

  /**
   * Get user by ID
   * @async
   * @param {number} userId - User ID
   * @returns {Promise<Object|null>} User object or null if not found
   * @throws {Error} If retrieval fails
   * 
   * @example
   * const user = await userService.getUserById(1);
   */
  async getUserById(userId) {
    const tracer = trace.getTracer('user-service');
    return tracer.startActiveSpan('user.getById', async (span) => {
      try {
        span.setAttribute('user.id', userId);
        const user = await UserModel.findById(userId);

        if (!user) {
          logger.warn('User not found', { userId });
          return null;
        }

        logger.info('User retrieved successfully', { userId });
        return user;
      } catch (error) {
        span.recordException(error);
        logger.error('User retrieval failed', { error: error.message, userId });
        throw error;
      } finally {
        span.end();
      }
    });
  }

  /**
   * Get all users
   * @async
   * @returns {Promise<Array<Object>>} Array of user objects
   * @throws {Error} If retrieval fails
   * 
   * @example
   * const users = await userService.getAllUsers();
   */
  async getAllUsers() {
    const tracer = trace.getTracer('user-service');
    return tracer.startActiveSpan('user.getAll', async (span) => {
      try {
        const users = await UserModel.findAll();
        logger.info('Users retrieved successfully', { count: users.length });
        return users;
      } catch (error) {
        span.recordException(error);
        logger.error('Users retrieval failed', { error: error.message });
        throw error;
      } finally {
        span.end();
      }
    });
  }

  /**
   * Update user by ID
   * @async
   * @param {number} userId - User ID
   * @param {Object} updates - Fields to update
   * @param {string} [updates.name] - New name
   * @param {string} [updates.email] - New email
   * @returns {Promise<Object|null>} Updated user object or null if not found
   * @throws {Error} If update fails
   * 
   * @example
   * const user = await userService.updateUser(1, { name: 'Jane Doe' });
   */
  async updateUser(userId, updates) {
    const tracer = trace.getTracer('user-service');
    return tracer.startActiveSpan('user.update', async (span) => {
      try {
        span.setAttribute('user.id', userId);
        const user = await UserModel.update(userId, updates);
        logger.info('User updated successfully', { userId });
        return user;
      } catch (error) {
        span.recordException(error);
        if (error.code === 'P2025') {
          logger.warn('User not found for update', { userId });
          return null;
        }
        logger.error('User update failed', { error: error.message, userId });
        throw error;
      } finally {
        span.end();
      }
    });
  }

  /**
   * Delete user by ID
   * @async
   * @param {number} userId - User ID
   * @returns {Promise<boolean>} True if deleted, false if not found
   * @throws {Error} If deletion fails
   * 
   * @example
   * const deleted = await userService.deleteUser(1);
   */
  async deleteUser(userId) {
    const tracer = trace.getTracer('user-service');
    return tracer.startActiveSpan('user.delete', async (span) => {
      try {
        span.setAttribute('user.id', userId);
        await UserModel.delete(userId);
        logger.info('User deleted successfully', { userId });
        return true;
      } catch (error) {
        span.recordException(error);
        if (error.code === 'P2025') {
          logger.warn('User not found for deletion', { userId });
          return false;
        }
        logger.error('User deletion failed', { error: error.message, userId });
        throw error;
      } finally {
        span.end();
      }
    });
  }

  /**
   * Authenticate user with email and password
   * @async
   * @param {string} email - User email
   * @param {string} password - Plain text password
   * @returns {Promise<Object|null>} Authentication result with user and token, or null
   * @returns {Object} returns.user - User object without password
   * @returns {string} returns.token - JWT token
   * @throws {Error} If authentication process fails
   * 
   * @example
   * const result = await userService.authenticateUser('john@example.com', 'password123');
   * if (result) {
   *   console.log(result.token);
   * }
   */
  async authenticateUser(email, password) {
    const tracer = trace.getTracer('user-service');
    return tracer.startActiveSpan('user.authenticate', async (span) => {
      try {
        span.setAttribute('user.email', email);
        const user = await UserModel.findByEmail(email);

        if (!user) {
          logger.warn('Authentication failed - user not found', { email });
          return null;
        }

        const isValidPassword = await authService.comparePassword(password, user.password);
        if (!isValidPassword) {
          logger.warn('Authentication failed - invalid password', { email });
          return null;
        }

        const token = authService.generateToken({ userId: user.id, email: user.email });
        logger.info('User authenticated successfully', { userId: user.id });

        // Remove password from response
        const { password: _, ...userWithoutPassword } = user;
        return { user: userWithoutPassword, token };
      } catch (error) {
        span.recordException(error);
        logger.error('Authentication failed', { error: error.message, email });
        throw error;
      } finally {
        span.end();
      }
    });
  }
}

export default new UserService();



================================================
FILE: validators/userValidator.js
================================================
/**
 * @fileoverview Joi validation schemas for user operations.
 * @module validators/userValidator
 */

import Joi from 'joi';

/**
 * Schema for creating a new user
 * @type {Joi.ObjectSchema}
 * @constant
 */
const createUserSchema = Joi.object({
  email: Joi.string().email().required().messages({
    'string.email': 'Please provide a valid email address',
    'any.required': 'Email is required',
  }),
  password: Joi.string().min(6).required().messages({
    'string.min': 'Password must be at least 6 characters long',
    'any.required': 'Password is required',
  }),
  name: Joi.string().min(2).required().messages({
    'string.min': 'Name must be at least 2 characters long',
    'any.required': 'Name is required',
  }),
});

/**
 * Schema for updating an existing user
 * @type {Joi.ObjectSchema}
 * @constant
 */
const updateUserSchema = Joi.object({
  email: Joi.string().email().messages({
    'string.email': 'Please provide a valid email address',
  }),
  name: Joi.string().min(2).messages({
    'string.min': 'Name must be at least 2 characters long',
  }),
}).min(1); // At least one field must be present

/**
 * Schema for user login
 * @type {Joi.ObjectSchema}
 * @constant
 */
const loginSchema = Joi.object({
  email: Joi.string().email().required().messages({
    'string.email': 'Please provide a valid email address',
    'any.required': 'Email is required',
  }),
  password: Joi.string().required().messages({
    'any.required': 'Password is required',
  }),
});

export { createUserSchema, updateUserSchema, loginSchema };


